# Lab 1. Intro
1. Щоб вирішити перше завдання потрібно:
	- сконвертувати бінарний код у ASCII
	- переведемо у десяткову систему счислення
	- докодуємо Base64

2. Текст другого завдання у шіснадцятковій системі зчислення. Переведемо у десятичну та переберемо усі можливі 258 сімволів, що можуть бути використані у якості ключа. Прийдемо до висновку, що ключ `23` дає непаганий результат.
3. Скориставщись вказівами данного завдання, побудуємо індекс співпадінь для здвигу підстроки.
![image](./imgs/ioc.PNG)
Прийдемо до висновку, що довжина ключа становить 3 символи. Отже, для кожної позиції переберемо усі 256 можливих значення ключу. Відортуємо усі отримані тексти за порядком спадання кількості літер у тексті. Отримали 12 можлиаих комбінацій ключа.
	- **pos1**  76 or  77
	- **pos2**  48 or  49
 	- **pos3** 108 or 109 or 111
 Переберемо ці ймовірні ключі руками. Отримаємо ключ - `76, 48, 108`.
 4. В цій роботі будемо використовувати генетичний алогритм, що реалізовано в біблотеці `pygad`.
 В якості fitness function будемо використовувати правдоподібність (likelihood) дешифрованого тексту. Для цього завантажмо корпус тексту `genesis`. розіб'ємо його на сполучення по 4 літери (4-gramms). Підрахуємо частоти 4-gramms у тексті та у дешифрованому тексті. Замість перемноження ймовірностей у правдоподібность, використаємо звичний трюк - прологорифмуємо ймовірності та будемо знаходтит їх суму. Це зроблено для того, щоб не вилізти за межі машиннох точності. Тому, помножимо likelihood на -1, та будемо макимізувати це значення за допомогою генетичного алгоритму.
Схрещення робиться шляхом випадковх перестановок 16% символів у ключі. Зробимо 500 генерацій, з 250 організмами за генерацію. Ймовірність схрещення виставимо в 10%. Додаткових мутацій робити не будемо. 
Нажаль алгоритм не сходиться до глобального максимум, проте дає досить близький до правильного ключ. Далі було не дуже складно доповнити ключ до правильного.
